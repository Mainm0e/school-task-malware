package main

import (
	"bufio"
	"crypto/aes"
	"crypto/cipher"
	"encoding/base64"
	"fmt"
	"os"
)

// decryptKey decrypts the encrypted key using AES encryption with a passphrase
func decryptKey(encryptedKey string, encryptionKey []byte) ([]byte, error) {
	block, err := aes.NewCipher(encryptionKey)
	if err != nil {
		return nil, err
	}

	encryptedData, err := base64.URLEncoding.DecodeString(encryptedKey)
	if err != nil {
		return nil, err
	}

	if len(encryptedData) < aes.BlockSize {
		return nil, fmt.Errorf("encrypted data is too short")
	}

	iv := encryptedData[:aes.BlockSize]
	encryptedData = encryptedData[aes.BlockSize:]

	stream := cipher.NewCFBDecrypter(block, iv)
	stream.XORKeyStream(encryptedData, encryptedData)

	return encryptedData, nil
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: program <encryption_key>")
		return
	}

	encryptionKey := os.Args[1]
	// asking for password
	fmt.Println("Enter key: ")
	encryptedKey := ""
	// Create a scanner to read user input
	scanner := bufio.NewScanner(os.Stdin)

	// Flag to track whether input has been received
	inputReceived := false

	// Loop until the user enters something or the input is received
	for scanner.Scan() {
		// take input encrypted key
		encryptedKey = scanner.Text()
		// Set the flag to true
		inputReceived = true
		// Exit the loop
		break
	}

	// Check if there was an error scanning input
	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "error reading input:", err)
	}

	// If input was received, decrypt the key
	if inputReceived {
		key, err := decryptKey(encryptedKey, []byte(encryptionKey))
		if err != nil {
			fmt.Println("Error decrypting key:", err)
			return
		}
		fmt.Println("Decrypted key:", string(key))
	} else {
		fmt.Println("No input received. Exiting.")
	}
}
