package main

import (
	"bufio"
	"crypto/aes"
	"crypto/cipher"
	"encoding/base64"
	"fmt"
	"os"
)

// decryptKey decrypts the encrypted key using AES encryption with a passphrase
func decryptKey(encryptedKey string, encryptionKey []byte) ([]byte, error) {
	block, err := aes.NewCipher(encryptionKey)
	if err != nil {
		return nil, err
	}

	encryptedData, err := base64.URLEncoding.DecodeString(encryptedKey)
	if err != nil {
		return nil, err
	}

	if len(encryptedData) < aes.BlockSize {
		return nil, fmt.Errorf("encrypted data is too short")
	}

	iv := encryptedData[:aes.BlockSize]
	encryptedData = encryptedData[aes.BlockSize:]

	stream := cipher.NewCFBDecrypter(block, iv)
	stream.XORKeyStream(encryptedData, encryptedData)

	return encryptedData, nil
}

func main() {
	encryptionkey := os.Args[1]
	// asking for password
	fmt.Println("Enter key: ")
	encryptedKey := ""
	// Create a scanner to read user input
	scanner := bufio.NewScanner(os.Stdin)

	// Loop until the user enters something
	for scanner.Scan() {
		// take input encyped key and encryptionKey
		encryptedKey = scanner.Text()

	}

	// Check if there was an error scanning input
	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "error reading input:", err)
	}

	key, err := decryptKey(encryptedKey, []byte(encryptionkey))
	if err != nil {
		fmt.Println("Error decrypting key:", err)
		return
	}
	fmt.Println("Decrypted key:", string(key))
}
